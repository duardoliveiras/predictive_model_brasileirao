# -*- coding: utf-8 -*-
"""model-predictive-brasileirao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D62UnVOGGD_yGNpGJZMrca2ELaRf-ORR
"""

import numpy as np
import pandas as pd 
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
from sklearn.exceptions import UndefinedMetricWarning

from google.colab import drive
drive.mount('/content/drive')

"""A tabela disponivel em: https://www.kaggle.com/datasets/josevitormichelin/brazilian-football-championship-brasileiro possuia apenas dados até 2019 enquanto nossa tabela com o dados das partidas disponivel em: https://www.kaggle.com/datasets/adaoduque/campeonato-brasileiro-de-futebol possuia até 2022. Então completei os dados da tabela de ranking utilizando informações disponíveis no site da CBF: https://www.cbf.com.br/.

Planilhas atualizadas com dados até 2022:
https://drive.google.com/drive/folders/1hCpd91iioJM1A8sHTVn1yYbswzpck7XR?usp=sharing
"""

ranking = pd.read_csv("/content/drive/MyDrive/IA_FUTEBOL_DADOS/dataset-2003-2022.csv", sep=',') # lendo a tabela 

ranking['team'] = ranking['team'].str.strip() # tirando espaço em branco dos nomes dos times

# padronizando nomes das duas bases de dados
ranking['team'] = ranking['team'].str.replace('América Mineiro','America-MG')
ranking['team'] = ranking['team'].str.replace('América-MG','America-MG')
ranking['team'] = ranking['team'].str.replace('Athletico Paranaense','Athletico-PR')
ranking['team'] = ranking['team'].str.replace('Athlético Paranaense','Athletico-PR')
ranking['team'] = ranking['team'].str.replace('Atlético Paranaense','Athletico-PR')
ranking['team'] = ranking['team'].str.replace('Atlético Mineiro','Atletico-MG')
ranking['team'] = ranking['team'].str.replace('Atlético Goianiense','Atletico-GO')
ranking['team'] = ranking['team'].str.replace('Avaí','Avai')
ranking['team'] = ranking['team'].str.replace('Ceará','Ceara')
ranking['team'] = ranking['team'].str.replace('Criciúma','Criciuma')
ranking['team'] = ranking['team'].str.replace('Cuiabá','Cuiaba')
ranking['team'] = ranking['team'].str.replace('Goiás','Goias')
ranking['team'] = ranking['team'].str.replace('Grêmio','Gremio')
ranking['team'] = ranking['team'].str.replace('Paraná','Parana')
ranking['team'] = ranking['team'].str.replace('São Paulo','Sao Paulo')
ranking['team'] = ranking['team'].str.replace('Vasco da Gama','Vasco')
ranking['team'] = ranking['team'].str.replace('Vitória','Vitoria')


filtro_campeao = ranking['position'] == 1 # filtro somente dos campeoes
filtro_vice = ranking['position'] == 2 # filtro dos vices

vencedores = ranking[filtro_campeao] # tabela campeoes
vice = ranking[filtro_vice] # tabela vices

ranking

vice

plt.figure(figsize=(12,6))
plt.title("Campeões")
sns.countplot(data=vencedores, x='team',order=vencedores['team'].value_counts().index)
plt.show()

plt.figure(figsize=(18,6))
plt.title("Vices-Campeões")
sns.countplot(data=vice, x='team',order=vice['team'].value_counts().index)
plt.show()

equipes = {} # dicionario que cria um numero (index) para cada nome de time
index = 0

for idx, row in ranking.iterrows():
  name = row['team']
  if(name not in equipes.keys()):
    equipes[name] = index
    index += 1
dict(sorted(equipes.items()))

campeoes = vencedores['team'].value_counts()
campeoes

def alterar_nome_id(df): # funcao para alterar o nome do time pelo index gerado
  df['team'] = equipes[df['team']]
  return df

ranking_id = ranking.apply(alterar_nome_id, axis='columns') # aplica a funcao de alterar nome
ranking_id

# implementando os modelos de machine learning

from sklearn.tree import DecisionTreeClassifier  
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC


from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report

X = ranking_id.drop(['position','year','goals_difference','games'], axis = 1) # dropando colunas que não importam
y = ranking_id['position'] # posicao

X

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=47) # separando o modelo em treino e teste

# carregando os modelos
decision_tree_model = DecisionTreeClassifier()
knn_model = KNeighborsClassifier(n_neighbors = 1)
random_forest_model = RandomForestClassifier()

# treinando os modelos
decision_tree_model.fit(X_train, y_train)
knn_model.fit(X_train, y_train)
random_forest_model.fit(X_train, y_train)

# salvando a predição de cada modelo
y_pred_tree = decision_tree_model.predict(X_test)
y_pred_knn = knn_model.predict(X_test)
y_pred_forest = random_forest_model.predict(X_test)

# printando resultados obtidos
with warnings.catch_warnings():
    warnings.filterwarnings("ignore", category=UndefinedMetricWarning)
    print(classification_report(y_test, y_pred_tree)) # 29%
    print(classification_report(y_test, y_pred_knn)) # 18%
    print(classification_report(y_test, y_pred_forest)) # 27%

"""Agora tentarei criar um modelo utilizando uma base de dados com estatisticas de cada partida"""

from sklearn.utils import shuffle # embaralhar dados
from xgboost import XGBClassifier # modelo de previsao XGboost
from sklearn.metrics import confusion_matrix # matriz de confusao

# importa dados das planilhas de partidas
matches = pd.read_csv("/content/drive/MyDrive/IA_FUTEBOL_DADOS/campeonato-brasileiro-full.csv") 
gols = pd.read_csv("/content/drive/MyDrive/IA_FUTEBOL_DADOS/campeonato-brasileiro-gols.csv")

matches['data'] = pd.to_datetime(matches['data'], format='%d/%m/%Y') # formata a data
filtro = (matches['data'] > '2003-01-01') & (matches['data'] < '2022-12-31') # filtr de dados de 2003 a 2022 para ficar compativel com nossa base de ranking

# group by das planilhas

##count = gols.groupby(['partida_id','clube']).size()
##matches['gols_mandante'] = matches[['ID','mandante']].apply(lambda x: count.get((x['ID'], x['mandante']), 0), axis=1)
##matches['gols_visitante'] = matches[['ID','visitante']].apply(lambda x: count.get((x['ID'], x['visitante']), 0), axis=1)


matches = matches[filtro] # aplica o filtro de data
matches = matches.dropna() # dropa dados vazios

matches

# funcao pra criar um index pro nome do time
def index_nome_team(df):
  equipes = {}
  index = 0

  for idx, row in df.iterrows():
    name = row['mandante']
    if(name not in equipes.keys()):
      equipes[name] = index
      index += 1
    name = row['visitante']
    if(name not in equipes.keys()):
      equipes[name] = index
      index += 1
  return equipes

equipes = index_nome_team(matches)
dict(sorted(equipes.items()))

# limpando base
matches_clear = matches.drop(['ID','data','hora','arena', 
                              'formacao_mandante', 'formacao_visitante', 
                              'tecnico_mandante','tecnico_visitante', 
                              'mandante_Estado', 'visitante_Estado','rodata'], axis = 1) 
# tabela limpa
matches_clear

campeoes

# adicionando colunas de vitoria do mandante de visitante
matches_clear['mandante_vitorias'] = 0
matches_clear['visitante_vitorias'] = 0

# contador de vitorias (titulo do campeonato), verifica na tabela de ranking quantos anos o time ficou no primeiro lugar
def count_vitorias(df):
  if(campeoes.get(df['mandante'])!= None ):
    df['mandante_vitorias'] = campeoes.get(df['mandante'])
  if(campeoes.get(df['visitante'])!= None ):
    df['visitante_vitorias'] = campeoes.get(df['visitante'])
  return df

matches_clear = matches_clear.apply(count_vitorias, axis='columns')
matches_clear

# altera o nome pelo index
def alterar_nome_index(df):
  # se o mandante venceu = 1
  # se o visitante venceu = 2
  # se empate = 0
  if(df['vencedor'] == df['mandante']):
      df['vencedor'] = 1
  elif(df['vencedor'] == df['visitante']):
      df['vencedor'] = 2
  else:
      df['vencedor'] = 0

  # troca o nome do time pelo indice
  df['mandante'] = equipes[df['mandante']]
  df['visitante'] = equipes[df['visitante']]



  return df

# aplica a funcao na tabela matches_clear
matches_id = matches_clear.apply(alterar_nome_index, axis='columns')
matches_id

# realizando o recorte da base, : (todas as linhas), das colunas []
# funcao loc realiza um recorte do dataframa a das linhas e colunas
X = matches_id.loc[:,['mandante','visitante','mandante_vitorias','visitante_vitorias']]

# convertendo o dataframe em um vetor array do tipo float para aplicar funcoes da lib NumPy
X = np.array(X).astype('float64')

_X = X.copy() # copia dos dados
# inverte a primeira e a segunda coluna
_X[:,0] = X[:,1]
_X[:,1] = X[:,0]
# inverte a terceira e a quarta coluna
_X[:,2] = X[:,3]
_X[:,3] = X[:,2]

# funcao loc para recortar todas as linhas da coluna vencedor
y = matches_id.loc[:,['vencedor']]
# transforma o dataframe em um array NumPy do tipo INT (pois so possui 0,1,2)
y = np.array(y).astype('int') # matriz de um coluna e varias linhas 
# transforma a matriz coluna em matriz linha
y = np.reshape(y,(1,3048)) # matriz de uma linha e varias colunas
# transforma y em um array unidimensional, vetor de varias posicoes
y = y[0]

# cria um copia de y
_y = y.copy() 

# inverto a resposta da copia do y
for i in range(len(_y)):
  if(_y[i] == 1):
    _y[i] = 2
  elif(_y[i] == 2):
    _y[i] = 1

# como a base de dados não é muito grande, utilizamos essa tática de duplicar os dados
# o que esta sendo feito aqui é: como a distribuição dos rótulos é desbalanceada, criamos
# um conjunto de dados sintético com rótulos invertidos para equilibrar a distribuição

# junto o vetor de dados original + o vetor de dados invertidos
X = np.concatenate((X,_X), axis=0)
y = np.concatenate((y,_y))

# embaralho os dados
X,y = shuffle(X,y)

# separo em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.25)

print(y_train)

# instancio o modelo SVC
model_svc = SVC(kernel='rbf', class_weight='balanced',probability=True)
# treino o modelo SVC
model_svc.fit(X_train,y_train)

# testando modelo SVC
y_pred = model_svc.predict(X_test)

# printa a classificao dos resultados
print(classification_report(y_test, y_pred))
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, cmap="Blues")
plt.xlabel('Classe Prevista')
plt.ylabel('Classe Real')
plt.show()

# testando o modelo kNN
knn_model.fit(X_train,y_train)
y_pd_knn = knn_model.predict(X_test)

print(classification_report(y_test, y_pd_knn))

cm = confusion_matrix(y_test, y_pd_knn)
sns.heatmap(cm, annot=True, cmap="Reds")
plt.xlabel('Classe Prevista')
plt.ylabel('Classe Real')
plt.show()

# testando o modelo de arvore de decisao
decision_tree_model.fit(X_train,y_train)
y_pd_tree = decision_tree_model.predict(X_test)

print(classification_report(y_test, y_pd_tree))

cm = confusion_matrix(y_test, y_pd_tree)
sns.heatmap(cm, annot=True, cmap="Oranges")
plt.xlabel('Classe Prevista')
plt.ylabel('Classe Real')
plt.show()

# testando o modelo de classificao xgboost
classifier = XGBClassifier()
classifier.fit(X_train, y_train)

y_pd_class = classifier.predict(X_test)

cm = confusion_matrix(y_test, y_pd_class)
sns.heatmap(cm, annot=True, cmap="Greens")
plt.xlabel('Classe Prevista')
plt.ylabel('Classe Real')
plt.show()

print(classification_report(y_test, y_pd_class))

"""Testado os quatros modelos, daremos continuidade com o SVC pois foi o que apresentou melhores resultados."""

# crio uma funcao para testar o resultando entre disputa de dois times
def previsao_times(mandante, visitante):
  # pega o id do time de entrada
  id_mandante = equipes[mandante] 
  id_visitante = equipes[visitante]
  
  # verifica se os times de entrada foram campeoes alguma vez, senao retorna 0
  campeao_mandante = campeoes.get(mandante) if campeoes.get(mandante) != None else 0
  campeao_visitante = campeoes.get(visitante) if campeoes.get(visitante) != None else 0

  # crio um array de dados com os dados necessarios para passar pro modelo. Dados do tipo float
  x = np.array([id_mandante, id_visitante, campeao_mandante, campeao_visitante]).astype('float64')
  # redimensiono o array x para transformalo em uma matriz unidimensional com uma linha
  # queremos saber a previsao para sobre um dado
  x = np.reshape(x, (1, -1))

  # a funcao predict_proba retorna a probabilidade para cada uma das classes
  # o [0] quer dizer somente a primeira linha da matriz de entrada x.
  y = model_svc.predict_proba(x)[0] # aplica o modelo na primeira linha da matriz x e retorn a probabilidade para a varial y
  # y[0] = probabilidade de dar empate pois 0 foi classificado como empate
  # y[1] = probabilidade do time mandante ganhar
  # y[2] = probabilidade do time visitante ganhar

  # texto retornando o resultado
  resultado = (mandante+ ' {}\n' +visitante+ ' {}\nEmpate {}').format(round(y[1]*100,2), round(y[2]*100,2), round(y[0]*100,2))
  return resultado

"""Exemplo prático: peguei 7 partidas do brasileirão 2020 da rodada 30/38
1. Palmeiras 1 x 1 Gremio
2. Fluminense 1 x 0 Sport
3. Vasco 0 x 1 Coritiba
4. Athletico-PR 1 x 1 São Paulo
5. Santos 2 x 1 Botafogo
6. Atlético MG 3 x 1 Atlétigo GO
7. Internacional 4 x 2 Fortaleza

"""

resultado = previsao_times('Palmeiras','Gremio')
print(resultado)

resultado = previsao_times('Fluminense','Sport')
print(resultado)

resultado = previsao_times('Vasco','Coritiba')
print(resultado)

resultado = previsao_times('Sao Paulo','Athletico-PR')
print(resultado)

resultado = previsao_times('Santos','Botafogo-RJ')
print(resultado)

resultado = previsao_times('Atletico-MG','Atletico-GO')
print(resultado)

resultado = previsao_times('Internacional','Fortaleza')
print(resultado)

"""1. Palmeiras 1 x 1 Gremio `ML: Palmeiras R: Empate`
2. Fluminense 1 x 0 Sport `ML: Fluminense R: Fluminense`
3. Vasco 0 x 1 Coritiba `ML: Coritiba R: Coritiba`
4. Athletico-PR 1 x 1 São Paulo `ML: São Paulo R: Empate`
5. Santos 2 x 1 Botafogo `ML: Santos R: Santos`
6. Atlético MG 3 x 1 Atlétigo GO `ML: Atlético MG R: Atlético MG`
7. Internacional 4 x 2 Fortaleza `ML: Internacional R: Internacional`

Ou seja, em uma amostra de 7 partidas aleatórias do campeonato de 2020 obtivemos uma acertividade de 5/7 = `70%`

Pegando um amostra de 2023 da rodada 6/38 temos:
1. Bahia 2 x 3 Flamengo
2. Fluminense 2 x 0 Cuiaba
3. Palmeiras 1 x 1 Bragantino
4. Atletico-MG 2 x 0 Internacional
5. Gremio 0 x 0 Fortaleza
6. Vasco 0 x 1 Santos
7. Corinthians 1 x 1 Sao paulo
8. Athletico-PR 3 x 2 Coritiba
9. Goias 2 x 1 Botafogo-RJ
10. America-MG 0 x 4 Cruzeiro
"""

resultado = previsao_times('Bahia','Flamengo')
print(resultado)
print("\n")
resultado = previsao_times('Fluminense','Cuiaba')
print(resultado)
print("\n")
resultado = previsao_times('Palmeiras','Bragantino')
print(resultado)
print("\n")
resultado = previsao_times('Atletico-MG','Internacional')
print(resultado)
print("\n")
resultado = previsao_times('Gremio','Fortaleza')
print(resultado)
print("\n")
resultado = previsao_times('Vasco','Santos')
print(resultado)
print("\n")
resultado = previsao_times('Corinthians','Sao Paulo')
print(resultado)
print("\n")
resultado = previsao_times('Athletico-PR','Coritiba')
print(resultado)
print("\n")
resultado = previsao_times('Goias','Botafogo-RJ')
print(resultado)
print("\n")
resultado = previsao_times('America-MG','Cruzeiro')
print(resultado)
print("\n")

"""Como podemos ver ele acertou 7/10 70%
1. Bahia 2 x 3 Flamengo `ML: Flamengo R: Flamengo`
2. Fluminense 2 x 0 Cuiaba `ML: Fluminense R: Fluminense`
3. Palmeiras 1 x 1 Bragantino `ML: Palmeiras R: Empate`
4. Atletico-MG 2 x 0 Internacional `ML: Atletico-MG R: Atletico-MG`
5. Gremio 0 x 0 Fortaleza `ML: Gremio R: Empate`
6. Vasco 0 x 1 Santos `ML: Santos R: Santos`
7. Corinthians 1 x 1 Sao paulo `ML: Empate R: Empate`
8. Athletico-PR 3 x 2 Coritiba `ML: Coritiba R: Athletico-PR`
9. Goias 2 x 1 Botafogo-RJ `ML: Goias R: Goias`
10. America-MG 0 x 4 Cruzeiro `ML: Cruzeiro R: Cruzeiro`
"""